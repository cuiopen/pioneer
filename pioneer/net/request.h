/**
 * request.h
 *
 *  Created on: Sep 12, 2011
 *      Author: Vincent Zhang, ivincent.zhang@gmail.com
 */

/*    Copyright 2011 ~ 2013 Vincent Zhang, ivincent.zhang@gmail.com
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

#ifndef NET_REQUEST_H_
#define NET_REQUEST_H_

#include <string>
#include <deque>

#include <glog/logging.h>

#include <boost/uuid/uuid.hpp>

#include <pioneer/system/context.h>
#include <pioneer/net/ip.h>
#include <pioneer/rfc/message.h>
#include <pioneer/rfc/rfc.h>
#include <pioneer/rfc/clients.h>

namespace pioneer {
  namespace net {

    using std::string;
    using boost::uuids::uuid;

    enum class error_category {
      no_error = 0,
      net_error,
      rfc_error,
      system_error,
      std_error,
      lib_3rd_error,
      string_error,
      cstring_error,
      unknown_error
    };

    class session;
    typedef std::shared_ptr<session> session_ptr;

    /**
     * @see session
     * */
    class request {
    public:

      request(const uuid& session_id, const session_ptr& s, const char* message, size_t size, const string& source_ip_port) :
          _message(message, size),
          _session(s)
      {
        _fn_id = static_cast<int>(_message.header()->fn_id);
        _client_type = static_cast<rfc::client_type>(_message.header()->client_type);
        _return_type = static_cast<rfc::return_type>(_message.header()->return_type);
      }

      ~request() { }

    public:

      session_ptr session() const { return _session.lock(); }

      int fn_id() const { return _fn_id; }

      void invoke() noexcept {
        rfc::rfc_context context(_client_type, _session_id, _source_ip_port);
        rfc::rfc_result result;

        try {
          result = rfc::dispatcher_chain::dispatch(_fn_id, _rfc_str, context);
        }
        catch (const std::exception& err) {
          LOG(ERROR) << err.what();
          result = rfc::rfc_result {err.what(), error_category::std_error};
        }
        catch (const std::string& err) {
          LOG(ERROR) << "[" << err << "]";
          result = rfc::rfc_result {err, error_category::string_error};
        }
        catch (const char* err) {
          LOG(ERROR) << "[" << err << "]";
          result = rfc::rfc_result {err, error_category::cstring_error};
        }
        catch (...) {
          LOG(ERROR) << "Unexpected error!!!";
          result = rfc::rfc_result {"Unexpected error!!!", error_category::unknown_error};
        }

        respond(result);
      }

      void respond(const rfc::rfc_result& result) {
        DLOG(INFO) << "respond rfc " << _fn_id << " to " << _client_type << ", " << _source_ip_port;

        rfc::p2p_client client(_client_type, _source_ip_port);
        if (_return_type == rfc::rfc_async_callback) {
          client.call(rfc::builtin_rfc::resume_task, rfc::fn_ids::resume_task, _session_id, result, rfc::nilctx);
        }
        else if (_return_type == rfc::rfc_sync) {
          client.call(rfc::builtin_rfc::resume_thread, rfc::fn_ids::resume_thread, _session_id, result, rfc::nilctx);
        }
      }

    private:

      rfc::message _message;
      std::weak_ptr<pioneer::net::session> _session;

      uuid _session_id;
      int _fn_id;
      rfc::client_type _client_type;
      rfc::return_type _return_type;
      std::string _source_ip_port;
      std::string _rfc_str;
    };

    typedef std::shared_ptr<request> request_ptr;

    class session : public std::enable_shared_from_this<session> {
    public:

      session(const uuid& id) : _id(id) { }

      ~session() { }

      const uuid& id() const { return _id; }

    public:

      void build_request(const char* message, size_t size, const std::string& source_ip_port) {
        _request.reset(new net::request(_id, shared_from_this(), message, size, source_ip_port));
      }

      const request_ptr& request() const { return _request; }

    private:

      /*
       * Session id must be an uuid, since the session is cluster-global and can be generated by
       * different host
       * */
      uuid _id;
      request_ptr _request;
    };

    bool operator<(const session& lhs, const session& rhs) {
      return lhs.id() < rhs.id();
    }

    bool operator==(const session& lhs, const session& rhs) {
      return lhs.id() == rhs.id();
    }

    class session_manager : public atlas::singleton<session_manager> {
    private:

      friend class atlas::singleton<session_manager>;
      session_manager() = default;
      session_manager(session_manager&)= delete;
      session_manager& operator=(const session_manager&)= delete;

    public:

      const request_ptr& build_request(const std::string& source_ip_port, const char* data, size_t len) {
        const uuid& session_id = rfc::message::get_session_id(data, len);

        // DLOG(INFO) << "session : " << session_id;

        session_ptr s;
        bool found = false;

        // critical area
        {
          std::lock_guard<std::mutex> guard(_mutex);
          auto it = _sessions.find(session_id);
          found = (it != _sessions.end());

          if (found) {
            s = it->second;
          }
          else {
            // there is a session token, but we can not find a session in this node,
            // this means this is a request from an inner-cluster-client, we should
            // create one session with the pass-in session id
            s.reset(new session(session_id));
            _sessions.insert(std::make_pair(s->id(), s));
          }
        }

        s->build_request(data, len, source_ip_port);

        return s->request();
      }

      session_ptr get(const uuid& session_id) const {
        std::lock_guard<std::mutex> guard(_mutex);

        session_ptr s;
        auto it = _sessions.find(session_id);
        if (it != _sessions.end()) {
          s = it->second;
        }

        return s;
      }

      void remove(const uuid& session_id) {
        std::lock_guard<std::mutex> guard(_mutex);

        auto it = _sessions.find(session_id);
        if(it != _sessions.end()) {
          // if(it->second->request()->response()->is_cluster_canremove())
          _sessions.erase(session_id);
        }
      }

      size_t size() const {
        std::lock_guard<std::mutex> guard(_mutex);
        return _sessions.size();
      }

      void clear() {
        std::lock_guard<std::mutex> guard(_mutex);
        _sessions.clear();
      }

    private:

      mutable std::mutex _mutex;
      std::map<uuid, session_ptr> _sessions;
    };

  } // db
} // pioneer

#endif /* NET_REQUEST_H_ */
